import{Z as W,z as _,aO as A,a_ as D,a$ as R,aR as j,aG as M,b0 as V,b1 as F,aK as U}from"./iconBase-B4H0EjgV.js";import{a as o,p as y}from"./chunk-JMJ3UQ3L-CPumaeMD.js";function K(t,s){return`${t} returned \`undefined\`. Seems you forgot to wrap component within ${s}`}function L(t={}){const{name:s,strict:r=!0,hookName:e="useContext",providerName:n="Provider",errorMessage:a,defaultValue:c}=t,p=o.createContext(c);p.displayName=s;function x(){const g=o.useContext(p);if(!g&&r){const C=new Error(a??K(e,n));throw C.name="ContextError",W(Error,"captureStackTrace")&&_(Error.captureStackTrace)&&Error.captureStackTrace(C,x),C}return g}return[p.Provider,x,p]}const[X,ee]=L({name:"EnvironmentContext",hookName:"useEnvironmentContext",providerName:"<EnvironmentProvider />",strict:!1,defaultValue:{getRootNode:()=>document,getDocument:()=>document,getWindow:()=>window}});function Y(...t){return s=>{const r=[];for(const e of t)if(typeof e=="function"){const n=e(s);typeof n=="function"&&r.push(n)}else e&&(e.current=s);if(r.length)return()=>{for(const e of r)e()}}}function z(t){let s=Object.getOwnPropertyDescriptor(t.props,"ref")?.get,r=s&&"isReactWarning"in s&&s.isReactWarning;return r?t.ref:(s=Object.getOwnPropertyDescriptor(t,"ref")?.get,r=s&&"isReactWarning"in s&&s.isReactWarning,r?t.props.ref:t.props.ref||t.ref)}const E=t=>{const s=o.memo(o.forwardRef((r,e)=>{const{asChild:n,children:a,...c}=r;if(!n)return o.createElement(t,{...c,ref:e},a);if(!o.isValidElement(a))return null;const p=o.Children.only(a),x=z(p);return o.cloneElement(p,{...A(c,p.props),ref:e?Y(e,x):x})}));return s.displayName=t.displayName||t.name,s},G=()=>{const t=new Map;return new Proxy(E,{apply(s,r,e){return E(e[0])},get(s,r){const e=r;return t.has(e)||t.set(e,E(e)),t.get(e)}})},te=G(),se=()=>(t,s)=>s.reduce((r,e)=>{const[n,a]=r,c=e;return a[c]!==void 0&&(n[c]=a[c]),delete a[c],[n,a]},[{},{...t}]);function Z(t){const{key:s,recipe:r}=t,e=D();return o.useMemo(()=>{const n=r||(s!=null?e.getSlotRecipe(s):{});return e.sva(structuredClone(n))},[s,r,e])}const q=t=>t.charAt(0).toUpperCase()+t.slice(1),re=t=>{const{key:s,recipe:r}=t,e=q(s||r.className||"Component"),[n,a]=R({name:`${e}StylesContext`,errorMessage:`use${e}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${e}.Root />" `}),[c,p]=R({name:`${e}ClassNameContext`,errorMessage:`use${e}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${e}.Root />" `,strict:!1}),[x,g]=R({strict:!1,name:`${e}PropsContext`,providerName:`${e}PropsContext`,defaultValue:{}});function C(i){const{unstyled:l,...m}=i,u=Z({key:s,recipe:m.recipe||r}),[d,f]=o.useMemo(()=>u.splitVariantProps(m),[m,u]);return{styles:o.useMemo(()=>l?F:u(d),[l,d,u]),classNames:u.classNameMap,props:f}}function O(i,l={}){const{defaultProps:m}=l,u=d=>{const f=g(),N=o.useMemo(()=>V(m,f,d),[f,d]),{styles:h,classNames:v,props:P}=C(N);return y.jsx(n,{value:h,children:y.jsx(c,{value:v,children:y.jsx(i,{...P})})})};return u.displayName=i.displayName||i.name,u}return{StylesProvider:n,ClassNamesProvider:c,PropsProvider:x,usePropsContext:g,useRecipeResult:C,withProvider:(i,l,m)=>{const{defaultProps:u,...d}=m??{},f=j(i,{},d),N=o.forwardRef((h,v)=>{const P=g(),S=o.useMemo(()=>V(u??{},P,h),[P,h]),{styles:w,props:b,classNames:k}=C(S),T=k[l],$=y.jsx(n,{value:w,children:y.jsx(c,{value:k,children:y.jsx(f,{ref:v,...b,css:[w[l],S.css],className:M(S.className,T)})})});return m?.wrapElement?.($,S)??$});return N.displayName=i.displayName||i.name,N},withContext:(i,l,m)=>{const u=j(i,{},m),d=o.forwardRef((f,N)=>{const{unstyled:h,...v}=f,P=a(),w=p()?.[l];return y.jsx(u,{...v,css:[!h&&l?P[l]:void 0,f.css],ref:N,className:M(f.className,w)})});return d.displayName=i.displayName||i.name,d},withRootProvider:O,useStyles:a,useClassNames:p}},B=o.forwardRef(function(s,r){return y.jsx(U,{align:"center",...s,direction:"column",ref:r})});B.displayName="VStack";export{B as V,te as a,se as b,L as c,Y as d,re as e,ee as u};
